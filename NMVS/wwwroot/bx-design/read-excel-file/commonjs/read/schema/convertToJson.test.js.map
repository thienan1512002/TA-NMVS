{"version":3,"sources":["../../../source/read/schema/convertToJson.test.js"],"names":["date","convertToUTCTimezone","Date","describe","it","should","deep","equal","STATUS","prop","type","String","oneOf","rows","errors","error","row","column","value","getTime","getTimezoneOffset"],"mappings":";;;;AAAA;;AAEA;;AACA;;AACA;;;;;;;;AAEA,IAAMA,IAAI,GAAGC,oBAAoB,CAAC,IAAIC,IAAJ,CAAS,IAAT,EAAe,IAAI,CAAnB,EAAsB,EAAtB,CAAD,CAAjC;AAEAC,QAAQ,CAAC,eAAD,EAAkB,YAAM;AAC/BC,EAAAA,EAAE,CAAC,qBAAD,EAAwB,YAAM;AAC/B,kCAAS,cAAT,EAAyB,GAAzB,EAA8B,CAA9B,EAAiCC,MAAjC,CAAwCC,IAAxC,CAA6CC,KAA7C,CAAmD,CAAC,UAAD,EAAa,EAAb,CAAnD;AACA,oCAAW,mBAAX,EAAgCF,MAAhC,CAAuCC,IAAvC,CAA4CC,KAA5C,CAAkD,CAAC,UAAD,EAAa,GAAb,CAAlD;AACA,GAHC,CAAF,CAD+B,CAM/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEAH,EAAAA,EAAE,CAAC,qCAAD,EAAwC,YAAM;AAC/C,yBAAyB,gCAAc,CACtC,CACC,QADD,CADsC,EAItC,CACC,WADD,CAJsC,CAAd,EAOtB;AACFI,MAAAA,MAAM,EAAE;AACPC,QAAAA,IAAI,EAAE,QADC;AAEPC,QAAAA,IAAI,EAAEC,MAFC;AAGPC,QAAAA,KAAK,EAAE,CACN,SADM,EAEN,UAFM;AAHA;AADN,KAPsB,CAAzB;AAAA,QAAQC,IAAR,kBAAQA,IAAR;AAAA,QAAcC,MAAd,kBAAcA,MAAd;;AAkBAA,IAAAA,MAAM,CAACT,MAAP,CAAcC,IAAd,CAAmBC,KAAnB,CAAyB,CAAC;AACzBQ,MAAAA,KAAK,EAAE,SADkB;AAEzBC,MAAAA,GAAG,EAAE,CAFoB;AAGzBC,MAAAA,MAAM,EAAE,QAHiB;AAIzBP,MAAAA,IAAI,EAAEC,MAJmB;AAKzBO,MAAAA,KAAK,EAAE;AALkB,KAAD,CAAzB;AAOA,GA1BC,CAAF;AA2BA,CAnfO,CAAR,C,CAsfA;;AACA,SAASjB,oBAAT,CAA8BD,IAA9B,EAAoC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAO,IAAIE,IAAJ,CAASF,IAAI,CAACmB,OAAL,KAAiBnB,IAAI,CAACoB,iBAAL,KAA2B,EAA3B,GAAgC,IAA1D,CAAP;AACA","sourcesContent":["import convertToJson, { parseArray, getBlock } from './convertToJson'\n\nimport Integer from '../../types/Integer'\nimport URL from '../../types/URL'\nimport Email from '../../types/Email'\n\nconst date = convertToUTCTimezone(new Date(2018, 3 - 1, 24))\n\ndescribe('convertToJson', () => {\n\tit('should parse arrays', () => {\n\t\tgetBlock('abc\"de,f\"g,h', ',', 0).should.deep.equal(['abcde,fg', 10])\n\t\tparseArray(' abc\"de,f\"g  , h ').should.deep.equal(['abcde,fg', 'h'])\n\t})\n\n\t// it('should convert to json', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'DATE',\n\t// \t\t\t'NUMBER',\n\t// \t\t\t'BOOLEAN',\n\t// \t\t\t'STRING',\n\t// \t\t\t'PHONE',\n\t// \t\t\t'PHONE_TYPE'\n\t// \t\t], [\n\t// \t\t\tnew Date(Date.parse('03/24/2018') - new Date().getTimezoneOffset() * 60 * 1000), // '43183', // '03/24/2018',\n\t// \t\t\t'123',\n\t// \t\t\ttrue,\n\t// \t\t\t'abc',\n\t// \t\t\t'(123) 456-7890',\n\t// \t\t\t'(123) 456-7890'\n\t// \t\t]\n\t// \t], {\n\t// \t\tDATE: {\n\t// \t\t\tprop: 'date',\n\t// \t\t\ttype: Date\n\t// \t\t},\n\t// \t\tNUMBER: {\n\t// \t\t\tprop: 'number',\n\t// \t\t\ttype: Number\n\t// \t\t},\n\t// \t\tBOOLEAN: {\n\t// \t\t\tprop: 'boolean',\n\t// \t\t\ttype: Boolean\n\t// \t\t},\n\t// \t\tSTRING: {\n\t// \t\t\tprop: 'string',\n\t// \t\t\ttype: String\n\t// \t\t},\n\t// \t\tPHONE: {\n\t// \t\t\tprop: 'phone',\n\t// \t\t\tparse(value) {\n\t// \t\t\t\treturn '+11234567890'\n\t// \t\t\t}\n\t// \t\t},\n\t// \t\tPHONE_TYPE: {\n\t// \t\t\tprop: 'phoneType',\n\t// \t\t\ttype(value) {\n\t// \t\t\t\treturn '+11234567890'\n\t// \t\t\t}\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([])\n\n\t// \t// Convert `Date` to `String` for equality check.\n\t// \trows[0].date = rows[0].date.toISOString()\n\n\t// \trows.should.deep.equal([{\n\t// \t\tdate: \"2018-03-24T00:00:00.000Z\",\n\t// \t\tnumber: 123,\n\t// \t\tphone: '+11234567890',\n\t// \t\tphoneType: '+11234567890',\n\t// \t\tboolean: true,\n\t// \t\tstring: 'abc'\n\t// \t}])\n\t// })\n\n\t// it('should support schema entries with no `type`s', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'DATE',\n\t// \t\t\t'NUMBER',\n\t// \t\t\t'BOOLEAN',\n\t// \t\t\t'STRING'\n\t// \t\t], [\n\t// \t\t\tnew Date(Date.parse('03/24/2018') - new Date().getTimezoneOffset() * 60 * 1000), // '43183', // '03/24/2018',\n\t// \t\t\t123,\n\t// \t\t\ttrue,\n\t// \t\t\t'abc'\n\t// \t\t]\n\t// \t], {\n\t// \t\tDATE: {\n\t// \t\t\tprop: 'date'\n\t// \t\t},\n\t// \t\tNUMBER: {\n\t// \t\t\tprop: 'number'\n\t// \t\t},\n\t// \t\tBOOLEAN: {\n\t// \t\t\tprop: 'boolean'\n\t// \t\t},\n\t// \t\tSTRING: {\n\t// \t\t\tprop: 'string'\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([])\n\n\t// \t// Convert `Date` to `String` for equality check.\n\t// \trows[0].date = rows[0].date.toISOString()\n\n\t// \trows.should.deep.equal([{\n\t// \t\tdate: date.toISOString(),\n\t// \t\tnumber: 123,\n\t// \t\tboolean: true,\n\t// \t\tstring: 'abc'\n\t// \t}])\n\t// })\n\n\t// it('should require fields', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'NUMBER'\n\t// \t\t], [\n\t// \t\t\tnull\n\t// \t\t]\n\t// \t], {\n\t// \t\tNUMBER: {\n\t// \t\t\tprop: 'number',\n\t// \t\t\ttype: Number,\n\t// \t\t\trequired: true\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([{\n\t// \t\terror: 'required',\n\t// \t\trow: 1,\n\t// \t\tcolumn: 'NUMBER',\n\t// \t\ttype: Number,\n\t// \t\tvalue: null\n\t// \t}])\n\n\t// \trows.should.deep.equal([])\n\t// })\n\n\t// it('should parse arrays', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'NAMES'\n\t// \t\t], [\n\t// \t\t\t'Barack Obama, \"String, with, colons\", Donald Trump'\n\t// \t\t], [\n\t// \t\t\tnull\n\t// \t\t]\n\t// \t], {\n\t// \t\tNAMES: {\n\t// \t\t\tprop: 'names',\n\t// \t\t\ttype: [String]\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([])\n\n\t// \trows.should.deep.equal([{\n\t// \t\tnames: ['Barack Obama', 'String, with, colons', 'Donald Trump']\n\t// \t}])\n\t// })\n\n\t// it('should parse integers', () =>\n\t// {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'INTEGER'\n\t// \t\t], [\n\t// \t\t\t'1'\n\t// \t\t], [\n\t// \t\t\t'1.2'\n\t// \t\t]\n\t// \t], {\n\t// \t\tINTEGER: {\n\t// \t\t\tprop: 'value',\n\t// \t\t\ttype: Integer\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.length.should.equal(1)\n\t// \terrors[0].row.should.equal(2)\n\t// \terrors[0].column.should.equal('INTEGER')\n\t// \terrors[0].error.should.equal('invalid')\n\n\t// \trows.should.deep.equal([{\n\t// \t\tvalue: 1\n\t// \t}])\n\t// })\n\n\t// it('should parse URLs', () =>\n\t// {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'URL'\n\t// \t\t], [\n\t// \t\t\t'https://kremlin.ru'\n\t// \t\t], [\n\t// \t\t\t'kremlin.ru'\n\t// \t\t]\n\t// \t], {\n\t// \t\tURL: {\n\t// \t\t\tprop: 'value',\n\t// \t\t\ttype: URL\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.length.should.equal(1)\n\t// \terrors[0].row.should.equal(2)\n\t// \terrors[0].column.should.equal('URL')\n\t// \terrors[0].error.should.equal('invalid')\n\n\t// \trows.should.deep.equal([{\n\t// \t\tvalue: 'https://kremlin.ru'\n\t// \t}])\n\t// })\n\n\t// it('should parse Emails', () =>\n\t// {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'EMAIL'\n\t// \t\t], [\n\t// \t\t\t'vladimir.putin@kremlin.ru'\n\t// \t\t], [\n\t// \t\t\t'123'\n\t// \t\t]\n\t// \t], {\n\t// \t\tEMAIL: {\n\t// \t\t\tprop: 'value',\n\t// \t\t\ttype: Email\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.length.should.equal(1)\n\t// \terrors[0].row.should.equal(2)\n\t// \terrors[0].column.should.equal('EMAIL')\n\t// \terrors[0].error.should.equal('invalid')\n\n\t// \trows.should.deep.equal([{\n\t// \t\tvalue: 'vladimir.putin@kremlin.ru'\n\t// \t}])\n\t// })\n\n\t// it('should call .validate()', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'NAME'\n\t// \t\t], [\n\t// \t\t\t'George Bush'\n\t// \t\t]\n\t// \t], {\n\t// \t\tNAME: {\n\t// \t\t\tprop: 'name',\n\t// \t\t\ttype: String,\n\t// \t\t\trequired: true,\n\t// \t\t\tvalidate: (value) => {\n\t// \t\t\t\tif (value === 'George Bush') {\n\t// \t\t\t\t\tthrow new Error('custom-error')\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([{\n\t// \t\terror: 'custom-error',\n\t// \t\trow: 1,\n\t// \t\tcolumn: 'NAME',\n\t// \t\ttype: String,\n\t// \t\tvalue: 'George Bush'\n\t// \t}])\n\n\t// \trows.should.deep.equal([])\n\t// })\n\n\t// it('should validate numbers', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'NUMBER'\n\t// \t\t], [\n\t// \t\t\t'123abc'\n\t// \t\t]\n\t// \t], {\n\t// \t\tNUMBER: {\n\t// \t\t\tprop: 'number',\n\t// \t\t\ttype: Number,\n\t// \t\t\trequired: true\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([{\n\t// \t\terror: 'invalid',\n\t// \t\trow: 1,\n\t// \t\tcolumn: 'NUMBER',\n\t// \t\ttype: Number,\n\t// \t\tvalue: '123abc'\n\t// \t}])\n\n\t// \trows.should.deep.equal([])\n\t// })\n\n\t// it('should validate booleans', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'TRUE',\n\t// \t\t\t'FALSE',\n\t// \t\t\t'INVALID'\n\t// \t\t], [\n\t// \t\t\ttrue,\n\t// \t\t\tfalse,\n\t// \t\t\t'TRUE'\n\t// \t\t]\n\t// \t], {\n\t// \t\tTRUE: {\n\t// \t\t\tprop: 'true',\n\t// \t\t\ttype: Boolean,\n\t// \t\t\trequired: true\n\t// \t\t},\n\t// \t\tFALSE: {\n\t// \t\t\tprop: 'false',\n\t// \t\t\ttype: Boolean,\n\t// \t\t\trequired: true\n\t// \t\t},\n\t// \t\tINVALID: {\n\t// \t\t\tprop: 'invalid',\n\t// \t\t\ttype: Boolean,\n\t// \t\t\trequired: true\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([{\n\t// \t\terror: 'invalid',\n\t// \t\trow: 1,\n\t// \t\tcolumn: 'INVALID',\n\t// \t\ttype: Boolean,\n\t// \t\tvalue: 'TRUE'\n\t// \t}])\n\n\t// \trows.should.deep.equal([{\n\t// \t\ttrue: true,\n\t// \t\tfalse: false\n\t// \t}])\n\t// })\n\n\t// it('should validate dates', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'DATE',\n\t// \t\t\t'INVALID'\n\t// \t\t], [\n\t// \t\t\t43183, // 03/24/2018',\n\t// \t\t\t'-'\n\t// \t\t], [\n\t// \t\t\tdate, // 03/24/2018',,\n\t// \t\t\t'-'\n\t// \t\t]\n\t// \t], {\n\t// \t\tDATE: {\n\t// \t\t\tprop: 'date',\n\t// \t\t\ttype: Date,\n\t// \t\t\trequired: true\n\t// \t\t},\n\t// \t\tINVALID: {\n\t// \t\t\tprop: 'invalid',\n\t// \t\t\ttype: Date,\n\t// \t\t\trequired: true\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([{\n\t// \t\terror: 'invalid',\n\t// \t\trow: 1,\n\t// \t\tcolumn: 'INVALID',\n\t// \t\ttype: Date,\n\t// \t\tvalue: '-'\n\t// \t}, {\n\t// \t\terror: 'invalid',\n\t// \t\trow: 2,\n\t// \t\tcolumn: 'INVALID',\n\t// \t\ttype: Date,\n\t// \t\tvalue: '-'\n\t// \t}])\n\n\t// \trows.should.deep.equal([{\n\t// \t\tdate\n\t// \t}, {\n\t// \t\tdate\n\t// \t}])\n\t// })\n\n\t// it('should throw parse() errors', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'PHONE',\n\t// \t\t\t'PHONE_TYPE'\n\t// \t\t], [\n\t// \t\t\t'123',\n\t// \t\t\t'123'\n\t// \t\t]\n\t// \t], {\n\t// \t\tPHONE: {\n\t// \t\t\tprop: 'phone',\n\t// \t\t\tparse: () => {\n\t// \t\t\t\tthrow new Error('invalid')\n\t// \t\t\t}\n\t// \t\t},\n\t// \t\tPHONE_TYPE: {\n\t// \t\t\tprop: 'phoneType',\n\t// \t\t\tparse: () => {\n\t// \t\t\t\tthrow new Error('invalid')\n\t// \t\t\t}\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.should.deep.equal([{\n\t// \t\terror: 'invalid',\n\t// \t\trow: 1,\n\t// \t\tcolumn: 'PHONE',\n\t// \t\tvalue: '123'\n\t// \t}, {\n\t// \t\terror: 'invalid',\n\t// \t\trow: 1,\n\t// \t\tcolumn: 'PHONE_TYPE',\n\t// \t\tvalue: '123'\n\t// \t}])\n\n\t// \trows.should.deep.equal([])\n\t// })\n\n\t// it('should map row numbers', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'NUMBER'\n\t// \t\t], [\n\t// \t\t\t'123abc'\n\t// \t\t]\n\t// \t], {\n\t// \t\tNUMBER: {\n\t// \t\t\tprop: 'number',\n\t// \t\t\ttype: Number\n\t// \t\t}\n\t// \t}, {\n\t// \t\trowMap: [2, 5]\n\t// \t})\n\n\t// \terrors.should.deep.equal([{\n\t// \t\terror: 'invalid',\n\t// \t\trow: 6,\n\t// \t\tcolumn: 'NUMBER',\n\t// \t\ttype: Number,\n\t// \t\tvalue: '123abc'\n\t// \t}])\n\t// })\n\n\t// it('should validate \"oneOf\" (valid)', () => {\n\t// \tconst { rows, errors } = convertToJson([\n\t// \t\t[\n\t// \t\t\t'STATUS'\n\t// \t\t],\n\t// \t\t[\n\t// \t\t\t'STARTED'\n\t// \t\t]\n\t// \t], {\n\t// \t\tSTATUS: {\n\t// \t\t\tprop: 'status',\n\t// \t\t\ttype: String,\n\t// \t\t\toneOf: [\n\t// \t\t\t\t'STARTED',\n\t// \t\t\t\t'FINISHED'\n\t// \t\t\t]\n\t// \t\t}\n\t// \t})\n\n\t// \terrors.length.should.equal(0)\n\t// })\n\n\tit('should validate \"oneOf\" (not valid)', () => {\n\t\tconst { rows, errors } = convertToJson([\n\t\t\t[\n\t\t\t\t'STATUS'\n\t\t\t],\n\t\t\t[\n\t\t\t\t'SCHEDULED'\n\t\t\t]\n\t\t], {\n\t\t\tSTATUS: {\n\t\t\t\tprop: 'status',\n\t\t\t\ttype: String,\n\t\t\t\toneOf: [\n\t\t\t\t\t'STARTED',\n\t\t\t\t\t'FINISHED'\n\t\t\t\t]\n\t\t\t}\n\t\t})\n\n\t\terrors.should.deep.equal([{\n\t\t\terror: 'invalid',\n\t\t\trow: 1,\n\t\t\tcolumn: 'STATUS',\n\t\t\ttype: String,\n\t\t\tvalue: 'SCHEDULED'\n\t\t}])\n\t})\n})\n\n\n// Converts timezone to UTC while preserving the same time\nfunction convertToUTCTimezone(date) {\n\t// Doesn't account for leap seconds but I guess that's ok\n\t// given that javascript's own `Date()` does not either.\n\t// https://www.timeanddate.com/time/leap-seconds-background.html\n\t//\n\t// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\n\t//\n\treturn new Date(date.getTime() - date.getTimezoneOffset() * 60 * 1000)\n}\n"],"file":"convertToJson.test.js"}